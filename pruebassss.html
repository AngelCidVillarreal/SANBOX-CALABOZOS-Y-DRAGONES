<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D&D Web Tracker - La Guarida del Dragón</title>

    <style>
        body {
            font-family: 'Georgia', serif;
            background-image: url(pngtree-screenshot-of-a-dungeon-layout-with-a-candle-picture-image_2774994.jpg);
            color: #333;
            margin: 0;
            padding: 0;
        }

        header {
            background-color: #791e0a;
            color: white;
            padding: 20px;
            text-align: center;
            border-bottom: 5px solid #a8321d;
        }

        main {
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        section {
            background-color: white;
            padding: 20px;
            margin-bottom: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        h2 {
            color: #a8321d;
            border-bottom: 2px solid #ccc;
            padding-bottom: 10px;
        }

        /* Estilo para Fichas de Personajes */
        #pc-list, #enemy-list {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .character-sheet {
            border: 1px solid #ccc;
            padding: 15px;
            border-radius: 5px;
            background-color: #fffaf0;
            width: 350px; 
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.05);
        }
        
        .character-sheet label {
            display: inline-block;
            margin-bottom: 5px;
            width: 80px;
        }
        
        .character-sheet input[type="text"], 
        .character-sheet input[type="number"],
        .character-sheet input[type="color"] {
            width: 50px;
            margin-left: 5px;
        }
        
        .character-sheet input[type="color"] {
            width: 30px;
            height: 30px;
            vertical-align: middle;
            margin-top: 5px;
            padding: 0;
            border: none;
        }

        .character-sheet button {
            margin-top: 10px;
            margin-right: 5px;
            padding: 5px 10px;
            cursor: pointer;
        }

        .pc-inventory, .pc-abilities {
            margin-top: 10px;
            padding-top: 5px;
            border-top: 1px dashed #ccc;
        }
        
        .pc-inventory textarea, .pc-abilities textarea {
            width: 95%;
            min-height: 50px;
            resize: vertical;
        }

        /* Estilos del Mapa */
        #map-container {
            border: 5px solid #a8321d;
            background-color: #eee;
            margin-top: 15px;
            cursor: grab;
            position: relative;
            user-select: none;
        }

        #game-map-canvas {
            background-color: #333;
            background-image: none; 
            border: 1px solid #333;
        }
        
        #map-controls {
            margin-bottom: 10px;
            padding: 5px;
            background-color: #f0f0f0;
            border-radius: 4px;
        }
        
        #map-controls input[type="file"] {
            margin-right: 15px;
        }
        
        #map-controls button, #map-controls select {
            padding: 8px 15px;
            margin-right: 5px;
            cursor: pointer;
        }

        /* Estilos para el Diario */
        #campaign-journal textarea {
            width: 98%;
            min-height: 300px;
            padding: 10px;
            border: 1px solid #ccc;
            font-size: 14px;
            line-height: 1.5;
            box-sizing: border-box;
        }
        
        /* Estilos para el Control de Combate */
        #combat-calculator, #combat-notes {
            float: left;
            width: 48%;
            padding: 1%;
            box-sizing: border-box;
        }
        
        #combat-calculator h3 {
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 5px;
        }

        #combat-calculator input, #combat-calculator select {
            margin-right: 10px;
            padding: 5px;
        }
        
        #combat-result {
            margin-top: 15px;
            padding: 10px;
            border: 1px dashed #a8321d;
            background-color: #fffaf0;
        }
        
        #combat-notes textarea {
            width: 95%;
            min-height: 150px;
            padding: 5px;
            resize: vertical;
        }
        
        .clearfix::after {
            content: "";
            clear: both;
            display: table;
        }

    </style>
</head>
<body>

    <header>
        <h1>D&D Web Tracker 🎲📜</h1>
    </header>

    <main>
        <section id="dice-roller">
            <h2>Tirada de Dados</h2>
            <div class="dice-controls">
                <input type="number" id="num-dice" value="1" min="1" max="10">
                <select id="dice-type">
                    <option value="4">d4</option>
                    <option value="6">d6</option>
                    <option value="8">d8</option>
                    <option value="10">d10</option>
                    <option value="12">d12</option>
                    <option value="20" selected>d20</option>
                    <option value="100">d100</option>
                </select>
                <button id="roll-button">Tirar Dado</button>
            </div>
            <p id="roll-result">Resultado: -</p>
        </section>
        
        <hr>
        
        <section id="campaign-journal">
            <h2>Diario de Campaña (Notas de Sesión)</h2>
            <textarea id="journal-text" placeholder="Fecha, Puntos de Trama, NPCs Encontrados, Tesoros Obtenidos..."></textarea>
        </section>

        <hr>

        <section id="combat-control" class="clearfix">
            <h2>Control de Combate</h2>
            
            <div id="combat-calculator">
                <h3>Calculadora de Ataque</h3>
                <label>Bono de Ataque: +<input type="number" id="attack-bonus" value="5" min="0" style="width: 30px;"></label>
                <label>CA Objetivo: <input type="number" id="target-ac" value="15" min="1" style="width: 30px;"></label>
                <br><br>
                <label>Dado de Daño: <select id="damage-dice-type">
                    <option value="4">d4</option>
                    <option value="6" selected>d6</option>
                    <option value="8">d8</option>
                    <option value="10">d10</option>
                    <option value="12">d12</option>
                </select></label>
                <label>Nº Dados: <input type="number" id="num-damage-dice" value="1" min="1" style="width: 30px;"></label>
                <label>Bono Daño: +<input type="number" id="damage-bonus" value="3" min="0" style="width: 30px;"></label>
                <br><br>
                <button id="calculate-attack-button">Simular Ataque</button>
                
                <div id="combat-result">Resultado: -</div>
            </div>
            
            <div id="combat-notes">
                <h3>Notas de Combate</h3>
                <textarea id="combat-notes-text" placeholder="Turno 1: Bárbaro golpea al Goblin (3 daño). Goblin falla contraataque."></textarea>
            </div>

        </section>

        <hr class="clearfix">

        <section id="game-tracker">
            <h2>Gráfico de Juego / Seguimiento de Partida</h2>
            <table id="tracker-table">
                <thead>
                    <tr>
                        <th>Nombre</th>
                        <th>Iniciativa</th>
                        <th>PV Actuales</th>
                        <th>Clase Armadura (CA)</th>
                        <th>Acciones</th>
                    </tr>
                </thead>
                <tbody id="tracker-table-body">
                    </tbody>
            </table>
        </section>

        <hr>

        <section id="character-sheets">
            <h2>Fichas de Personajes (PCs)</h2>
            <button id="add-pc-button">Añadir Personaje</button>
            <div id="pc-list">
                </div>
        </section>

        <hr>

        <section id="enemy-sheets">
            <h2>Fichas de Enemigos / NPCs</h2>
            <button id="add-enemy-button">Añadir Enemigo</button>
            <div id="enemy-list">
                </div>
        </section>

        <hr>

        <section id="game-map">
            <h2>Mapa Cuadriculado (40x30 cuadros)</h2>
            <div id="map-controls">
                <label>Cargar Fondo: <input type="file" id="map-background-input" accept="image/*"></label>
                <button onclick="clearMapBackground()">Borrar Fondo</button>
                <hr style="margin: 10px 0;">
                
                <select id="decoration-type-select" onchange="updateDrawingMode()">
                    <option value="wall" selected>Muro (Piedra)</option>
                    <option value="water">Agua (Azul)</option>
                    <option value="treasure">Tesoro (Amarillo)</option>
                    <option value="hazard">Peligro (Rojo)</option>
                </select>
                <button onclick="setMapMode('decorate')" id="mode-decorate">Dibujar Decoración</button>
                <button onclick="setMapMode('erase')">Borrar Decoración</button>
                <button onclick="setMapMode('move')" id="mode-move">Mover Fichas</button>
                <button onclick="clearDecorations()">Borrar Todas las Decoraciones</button>
                <span style="margin-left: 20px;">Modo Actual: <strong id="current-mode">Mover Fichas</strong></span>
            </div>
            <div id="map-container">
                <canvas id="game-map-canvas" width="800" height="600"></canvas>
            </div>
        </section>

    </main>

    <footer>
        <p>© D&D Tracker Project. Hecho con HTML, CSS y JavaScript.</p>
    </footer>

    <script>
        // =================================================================
        // ESTRUCTURA DE DATOS GLOBAL & CONFIGURACIÓN
        // =================================================================
        let pcCount = 0;
        let enemyCount = 0;
        const tokens = []; 
        const decorations = []; 
        
        const GRID_SIZE = 20; 
        const MAP_WIDTH = 800;
        const MAP_HEIGHT = 600;

        let mapMode = 'move'; 
        let currentDecorationType = 'wall';
        const modeDisplay = document.getElementById('current-mode');
        
        const DECORATION_STYLES = {
            wall: { color: '#555555', stroke: '#333333', initial: 'M' },
            water: { color: '#0077c2', stroke: '#00558f', initial: 'A' },
            treasure: { color: '#ffd700', stroke: '#ccac00', initial: 'T' },
            hazard: { color: '#d32f2f', stroke: '#9a0007', initial: 'P' }
        };

        let mapBackground = null; 
        const trackerTableBody = document.getElementById('tracker-table-body');


        // =================================================================
        // 1. LANZADOR DE DADOS
        // =================================================================
        function rollDice(sides) {
            return Math.floor(Math.random() * sides) + 1;
        }

        const rollButton = document.getElementById('roll-button');
        const numDiceInput = document.getElementById('num-dice');
        const diceTypeSelect = document.getElementById('dice-type');
        const rollResultP = document.getElementById('roll-result');

        rollButton.addEventListener('click', () => {
            const numDice = parseInt(numDiceInput.value);
            const diceSides = parseInt(diceTypeSelect.value);
            
            if (isNaN(numDice) || numDice < 1) {
                rollResultP.textContent = "Error: Número de dados inválido.";
                return;
            }

            let totalRoll = 0;
            let individualRolls = [];

            for (let i = 0; i < numDice; i++) {
                const roll = rollDice(diceSides);
                individualRolls.push(roll);
                totalRoll += roll;
            }

            const resultText = `Tirada de ${numDice}d${diceSides}: **${totalRoll}** (Dados individuales: ${individualRolls.join(', ')})`;
            rollResultP.innerHTML = `Resultado: ${resultText}`;
        });
        
        // =================================================================
        // 2. CONTROL DE COMBATE Y CALCULADORA (NUEVO)
        // =================================================================
        
        const attackButton = document.getElementById('calculate-attack-button');
        const combatResultDiv = document.getElementById('combat-result');
        const combatNotesTextarea = document.getElementById('combat-notes-text');

        attackButton.addEventListener('click', () => {
            const attackBonus = parseInt(document.getElementById('attack-bonus').value) || 0;
            const targetAC = parseInt(document.getElementById('target-ac').value) || 10;
            const damageDiceType = parseInt(document.getElementById('damage-dice-type').value);
            const numDamageDice = parseInt(document.getElementById('num-damage-dice').value) || 1;
            const damageBonus = parseInt(document.getElementById('damage-bonus').value) || 0;

            if (isNaN(targetAC) || targetAC < 1) {
                combatResultDiv.textContent = "Error: CA objetivo inválida.";
                return;
            }

            // 1. Tirada de ataque
            const attackRoll = rollDice(20);
            const totalAttack = attackRoll + attackBonus;
            
            let resultText = `Tirada de Ataque (d20): **${attackRoll}** + ${attackBonus} = **${totalAttack}** (CA Objetivo: ${targetAC}).<br>`;
            
            let totalDamage = 0;
            let damageRolls = [];
            
            if (attackRoll === 20) {
                // Crítico (Tira el doble de dados de daño)
                const totalDamageDice = numDamageDice * 2;
                for (let i = 0; i < totalDamageDice; i++) {
                    const roll = rollDice(damageDiceType);
                    damageRolls.push(roll);
                    totalDamage += roll;
                }
                totalDamage += damageBonus;
                
                resultText += `<span style="color: red; font-weight: bold;">¡GOLPE CRÍTICO!</span> ¡Impacta (Total ${totalAttack} > ${targetAC})!<br>`;
                resultText += `Daño: **${totalDamage}** (Dados: ${damageRolls.join(', ')}) + ${damageBonus}.`;

            } else if (attackRoll === 1) {
                // Falla crítica
                resultText += `<span style="color: blue; font-weight: bold;">FALLO CRÍTICO.</span> Falla (Total ${totalAttack} < ${targetAC}). No hay daño.`;
            } else if (totalAttack >= targetAC) {
                // Impacto normal
                for (let i = 0; i < numDamageDice; i++) {
                    const roll = rollDice(damageDiceType);
                    damageRolls.push(roll);
                    totalDamage += roll;
                }
                totalDamage += damageBonus;
                
                resultText += `<span style="color: green; font-weight: bold;">¡IMPACTO!</span> (Total ${totalAttack} >= ${targetAC}).<br>`;
                resultText += `Daño: **${totalDamage}** (Dados: ${damageRolls.join(', ')}) + ${damageBonus}.`;
            } else {
                // Falla normal
                resultText += `<span style="color: black;">FALLA.</span> (Total ${totalAttack} < ${targetAC}). No hay daño.`;
            }
            
            combatResultDiv.innerHTML = resultText;
            
            // Opcional: Añadir nota al diario de combate
            const currentTime = new Date().toLocaleTimeString('es-ES', {hour: '2-digit', minute: '2-digit'});
            combatNotesTextarea.value += `\n[${currentTime}] Ataque (AC ${targetAC}): ${totalAttack} ${totalAttack >= targetAC ? '-> DAÑO: ' + totalDamage : '-> Falla.'}`;

        });

        // =================================================================
        // 3. FICHAS (PC/ENEMIGO)
        // =================================================================
        const pcList = document.getElementById('pc-list');
        const addPcButton = document.getElementById('add-pc-button');
        const enemyList = document.getElementById('enemy-list');
        const addEnemyButton = document.getElementById('add-enemy-button');
        
        function createSheet(type) {
            const isPC = type === 'pc';
            const list = isPC ? pcList : enemyList;
            let id;
            
            if (isPC) {
                pcCount++;
                id = `pc-${pcCount}`;
            } else {
                enemyCount++;
                id = `enemy-${enemyCount}`;
            }

            const sheet = document.createElement('div');
            sheet.classList.add('character-sheet');
            sheet.id = id;
            
            const defaultName = isPC ? `Héroe ${pcCount}` : `Goblin ${enemyCount}`;
            const defaultHP = isPC ? 10 : 7;
            const defaultAC = isPC ? 15 : 13;
            const defaultColor = isPC ? '#007bff' : '#dc3545';
            
            // Añadir ficha al array de tokens
            tokens.push({
                id: id,
                name: defaultName,
                x: GRID_SIZE / 2 + (tokens.length * GRID_SIZE) % (MAP_WIDTH - GRID_SIZE), 
                y: GRID_SIZE / 2 + (tokens.length * GRID_SIZE) % (MAP_HEIGHT - GRID_SIZE),
                color: defaultColor, 
                type: type,
                radius: GRID_SIZE * 0.4
            });
            drawMap(); 

            sheet.innerHTML = `
                <h3>${isPC ? 'Personaje' : 'Enemigo'} <span id="${id}-name-display">${defaultName}</span></h3>
                <label>Nombre: <input type="text" id="${id}-name" value="${defaultName}" oninput="updateTokenNameAndDisplay('${id}', this.value)"></label><br>
                <label>Color Ficha: 
                    <input type="color" id="${id}-color" value="${defaultColor}" onchange="updateTokenColor('${id}', this.value)">
                </label><br>
                <label>PV Máx: <input type="number" id="${id}-max-hp" value="${defaultHP}" min="1"></label><br>
                <label>CA: <input type="number" id="${id}-ac" value="${defaultAC}" min="1"></label><br>
                
                ${isPC ? `
                    <label>Fuerza: <input type="number" class="stat" value="10"></label> (Mod: <span>+0</span>)<br>
                    
                    <div class="pc-abilities">
                        <h4>Habilidades (Especiales/Clase)</h4>
                        <textarea placeholder="Ataque Extra, Curar Heridas, Furia..."></textarea>
                    </div>
                    
                    <div class="pc-inventory">
                        <h4>Inventario</h4>
                        <textarea placeholder="Espada Larga, Ración, 50 piezas de oro..."></textarea>
                    </div>
                ` : `<label>Tipo: <input type="text" value="Humanoide"></label><br>`}
                
                <button onclick="
                    const name = document.getElementById('${id}-name').value;
                    const hp = document.getElementById('${id}-max-hp').value;
                    const ac = document.getElementById('${id}-ac').value;
                    addToGameTracker('${id}', name, hp, ac);
                ">Añadir a Partida</button>
                <button onclick="removeElement('${id}')">Eliminar Ficha</button>
            `;

            list.appendChild(sheet);
        }

        addPcButton.addEventListener('click', () => createSheet('pc'));
        addEnemyButton.addEventListener('click', () => createSheet('enemy'));


        // =================================================================
        // 4. GRÁFICO DE JUEGO (TRACKER)
        // =================================================================

        function addToGameTracker(id, name, hp, ac) {
            if (document.getElementById(`tracker-${id}`)) {
                alert(`${name} ya está en la tabla de seguimiento.`);
                return;
            }

            const initiative = prompt(`Introduce la Iniciativa (d20 + mod) para ${name}:`);
            if (!initiative || isNaN(parseInt(initiative))) {
                alert("Iniciativa inválida. Se necesita un número.");
                return;
            }
            
            const row = trackerTableBody.insertRow();
            row.id = `tracker-${id}`;
            row.setAttribute('data-init', parseInt(initiative));
            row.setAttribute('data-max-hp', parseInt(hp));
            
            row.insertCell().textContent = name;
            row.insertCell().textContent = initiative;
            row.insertCell().innerHTML = `<span id="hp-${id}">${hp}</span> / ${hp}`;
            row.insertCell().textContent = ac;
            
            const actionsCell = row.insertCell();
            actionsCell.innerHTML = `
                <button onclick="manageHP('${id}', 'damage')">Daño</button>
                <button onclick="manageHP('${id}', 'heal')">Curar</button>
                <button onclick="removeElement('tracker-${id}')">X</button>
            `;
            
            sortTrackerTable();
        }

        function sortTrackerTable() {
            let rows = Array.from(trackerTableBody.querySelectorAll('tr'));
            
            rows.sort((a, b) => {
                const initA = parseInt(a.getAttribute('data-init'));
                const initB = parseInt(b.getAttribute('data-init'));
                return initB - initA; 
            });

            rows.forEach(row => trackerTableBody.appendChild(row));
        }
        
        function manageHP(id, action) {
            const row = document.getElementById(`tracker-${id}`);
            if (!row) return;

            const hpSpan = document.getElementById(`hp-${id}`);
            const maxHP = parseInt(row.getAttribute('data-max-hp'));
            let currentHP = parseInt(hpSpan.textContent);

            const amountStr = prompt(`Introduce la cantidad de ${action === 'damage' ? 'Daño' : 'Curación'}:`);
            const amount = parseInt(amountStr);

            if (isNaN(amount) || amount <= 0) {
                alert("Cantidad inválida.");
                return;
            }

            if (action === 'damage') {
                currentHP -= amount;
            } else {
                currentHP = Math.min(maxHP, currentHP + amount);
            }

            hpSpan.textContent = currentHP;

            if (currentHP <= 0) {
                row.style.backgroundColor = '#ffc0c0'; 
            } else if (currentHP < maxHP) {
                row.style.backgroundColor = '#fff7c0'; 
            } else {
                row.style.backgroundColor = 'white'; 
            }
        }
        
        function updateTokenNameAndDisplay(id, newName) {
            const token = tokens.find(t => t.id === id);
            const displayName = newName || 'Sin Nombre';
            document.getElementById(`${id}-name-display`).textContent = displayName;

            if (token) {
                token.name = newName;
                drawMap();
            }
        }


        // =================================================================
        // 5. MAPA INTERACTIVO (CANVAS)
        // =================================================================
        const canvas = document.getElementById('game-map-canvas');
        const ctx = canvas.getContext('2d');
        
        let draggedToken = null;
        let startX, startY;

        function updateTokenColor(id, color) {
            const token = tokens.find(t => t.id === id);
            if (token) {
                token.color = color;
                drawMap();
            }
        }

        function setMapMode(mode) {
            mapMode = mode;
            modeDisplay.textContent = mode.charAt(0).toUpperCase() + mode.slice(1);
            
            const canvas = document.getElementById('game-map-canvas');
            if (mode === 'decorate' || mode === 'erase') {
                canvas.style.cursor = 'crosshair';
            } else {
                canvas.style.cursor = 'grab';
            }
        }
        
        function updateDrawingMode() {
            currentDecorationType = document.getElementById('decoration-type-select').value;
            if (mapMode === 'decorate' || mapMode === 'erase') {
                setMapMode('decorate'); 
            }
        }

        function getGridCoordinates(mouseX, mouseY) {
            const gridX = Math.floor(mouseX / GRID_SIZE) * GRID_SIZE;
            const gridY = Math.floor(mouseY / GRID_SIZE) * GRID_SIZE;
            return { x: gridX, y: gridY };
        }

        /** Carga de Imagen de Fondo */
        document.getElementById('map-background-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    mapBackground = new Image();
                    mapBackground.onload = function() {
                        drawMap(); 
                    };
                    mapBackground.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        function clearMapBackground() {
            mapBackground = null;
            document.getElementById('map-background-input').value = '';
            drawMap();
        }


        function drawDecorations() {
            decorations.forEach(deco => {
                const style = DECORATION_STYLES[deco.type] || DECORATION_STYLES.wall;
                
                ctx.fillStyle = style.color;
                ctx.fillRect(deco.x, deco.y, GRID_SIZE, GRID_SIZE);
                
                ctx.strokeStyle = style.stroke;
                ctx.lineWidth = 1;
                ctx.strokeRect(deco.x, deco.y, GRID_SIZE, GRID_SIZE);
                
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = 'bold 10px Arial';
                const initial = style.initial || '?';
                ctx.fillText(initial, deco.x + GRID_SIZE / 2, deco.y + GRID_SIZE / 2);

            });
        }

        function clearDecorations() {
            if (confirm("¿Estás seguro de que quieres borrar toda la decoración del mapa?")) {
                decorations.length = 0; 
                drawMap();
            }
        }
        
        function drawGridOverlay() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; 
            ctx.lineWidth = 1;

            for (let x = 0; x <= MAP_WIDTH; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, MAP_HEIGHT);
                ctx.stroke();
            }

            for (let y = 0; y <= MAP_HEIGHT; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(MAP_WIDTH, y);
                ctx.stroke();
            }
        }


        function drawMap() {
            // 1. Limpiar y dibujar fondo base
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (mapBackground) {
                ctx.drawImage(mapBackground, 0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = '#333';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // 2. Dibujar decoraciones (muros, agua, etc.)
            drawDecorations();
            
            // 3. Cuadrícula Transparente (siempre encima del fondo/decoración)
            drawGridOverlay(); 
            
            // 4. Dibujar las fichas (tokens) (siempre encima de todo lo demás)
            tokens.forEach(token => {
                ctx.beginPath();
                ctx.arc(token.x, token.y, token.radius, 0, Math.PI * 2);
                ctx.fillStyle = token.color;
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Texto (Inicial del Nombre)
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = 'bold 12px Arial'; 
                const initial = token.name ? token.name.charAt(0).toUpperCase() : '?';
                ctx.fillText(initial, token.x, token.y);
            });
        }
        
        /** Manejadores de Eventos del Ratón (Mismo código que antes) */
        
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const { x: gridX, y: gridY } = getGridCoordinates(mouseX, mouseY);

            if (mapMode === 'decorate') {
                const existingIndex = decorations.findIndex(d => d.x === gridX && d.y === gridY);
                
                if (existingIndex === -1) {
                    decorations.push({ x: gridX, y: gridY, type: currentDecorationType });
                } else if (decorations[existingIndex].type !== currentDecorationType) {
                    decorations[existingIndex].type = currentDecorationType;
                }
                drawMap();
            } else if (mapMode === 'erase') {
                const existingIndex = decorations.findIndex(d => d.x === gridX && d.y === gridY);
                if (existingIndex !== -1) {
                    decorations.splice(existingIndex, 1);
                    drawMap();
                }
            } else if (mapMode === 'move') {
                for (let i = tokens.length - 1; i >= 0; i--) {
                    const token = tokens[i];
                    const distance = Math.sqrt(Math.pow(mouseX - token.x, 2) + Math.pow(mouseY - token.y, 2));
                    
                    if (distance < token.radius) {
                        draggedToken = token;
                        startX = mouseX - token.x;
                        startY = mouseY - token.y;
                        canvas.style.cursor = 'grabbing';
                        tokens.splice(i, 1);
                        tokens.push(token);
                        break;
                    }
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (mapMode === 'move' && draggedToken) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientX - rect.top;

                const newGridX = Math.round((mouseX - startX) / GRID_SIZE) * GRID_SIZE;
                const newGridY = Math.round((mouseY - startY) / GRID_SIZE) * GRID_SIZE;

                draggedToken.x = newGridX + GRID_SIZE / 2;
                draggedToken.y = newGridY + GRID_SIZE / 2;
                
                draggedToken.x = Math.max(GRID_SIZE / 2, Math.min(canvas.width - GRID_SIZE / 2, draggedToken.x));
                draggedToken.y = Math.max(GRID_SIZE / 2, Math.min(canvas.height - GRID_SIZE / 2, draggedToken.y));


                drawMap();
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (mapMode === 'move') {
                draggedToken = null;
                canvas.style.cursor = 'grab';
            }
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Inicializar el dibujo del mapa al cargar la página
        window.onload = drawMap;
        setMapMode('move');
    </script>
</body>
</html>