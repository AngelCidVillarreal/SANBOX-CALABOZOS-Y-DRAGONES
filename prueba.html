<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D&D Aventuras RPG - Control de Campaña Dinámico (Simple)</title>
    <style>
        /* ======================================= */
        /* == ESTILOS GLOBALES Y DE FICHA (BASE) == */
        /* ======================================= */
        body {
            font-family: 'Times New Roman', serif;
            background-image: url(pngtree-screenshot-of-a-dungeon-layout-with-a-candle-picture-image_2774994.jpg);
            color: #333;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border: 4px solid #8b4513; 
            box-shadow: 10px 10px 15px rgba(0, 0, 0, 0.5);
            border-radius: 5px;
        }
        h1 {
            text-align: center;
            color: #4b0082;
            border-bottom: 3px double #8b4513;
            padding-bottom: 10px;
        }
        h2 {
            color: #8b0000;
            margin-top: 30px;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
        }
        .players-section, .enemies-section {
            display: flex;
            flex-wrap: wrap; 
            gap: 20px;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 1px dashed #ccc;
        }
        .player-card, .enemy-card {
            border: 2px solid #a0522d;
            padding: 15px;
            width: 300px;
            background-color: #fffaf0;
            border-radius: 5px;
            position: relative;
        }
        .enemy-card {
            background-color: #ffeaea; 
            border-color: #8b0000;
        }
        .player-card label, .enemy-card label {
            font-weight: bold;
            display: block;
            margin-top: 5px;
        }
        .player-card input[type="text"], .player-card input[type="number"],
        .enemy-card input[type="text"], .enemy-card input[type="number"] {
            width: 90%;
            padding: 3px;
            margin-bottom: 5px;
            border: 1px solid #ccc;
        }
        .player-card textarea { /* Estilo para el nuevo Inventario */
            width: 90%;
            min-height: 100px;
            padding: 5px;
            border: 1px solid #ccc;
            font-family: inherit;
        }
        .player-card input[type="color"] {
            width: 50px;
            height: 25px;
            vertical-align: middle;
        }
        .remove-card-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            color: #cc0000;
            font-weight: bold;
            cursor: pointer;
            padding: 5px;
            line-height: 1;
        }
        .add-card-btn-container {
            width: 100%;
            text-align: center;
            margin-top: 10px;
            margin-bottom: 20px;
        }
        .add-card-btn {
            background-color: #007bff;
            padding: 10px 20px;
            font-size: 1.1em;
            cursor: pointer;
            border: none;
            color: white;
            border-radius: 5px;
        }
        .add-card-btn:hover {
            background-color: #0056b3;
        }
        .add-enemy-btn {
            background-color: #8b0000;
        }
        .add-enemy-btn:hover {
            background-color: #640000;
        }
        .main-sections {
            display: flex;
            gap: 20px;
            margin-top: 40px;
        }
        .journal-section, .combat-control-section {
            flex: 1;
            border: 1px solid #000;
            padding: 15px;
            background-color: #fcf8e3;
            border-radius: 3px;
        }
        textarea {
            width: 98%;
            min-height: 250px;
            padding: 10px;
            border: 1px dashed #666;
            font-family: 'Times New Roman', serif;
            font-size: 1em;
        }
        .dice-roller {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            border: 2px solid black;
            background-color: #e0e0e0;
            border-radius: 5px;
        }
        .dice-result {
            font-size: 2.5em;
            font-weight: bold;
            color: #008000;
            margin-top: 15px;
        }
        
        /* ======================================= */
        /* == ESTILOS DE LA PIZARRA (SIMPLIFICADOS) == */
        /* ======================================= */
        .map-section {
            margin-top: 40px;
            padding: 20px;
            border: 2px solid #8b4513;
            background-color: #f7f7f7;
            border-radius: 5px;
        }
        #drawing-canvas {
            border: 1px solid #000;
            cursor: crosshair;
            background-color: #ffffff; 
            display: block;
            margin: 10px auto;
        }
        .canvas-controls {
            text-align: center;
            margin-bottom: 10px;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        .canvas-controls input,
        .canvas-controls select,
        .canvas-controls button {
            padding: 5px;
            margin: 0 2px;
            font-size: 1em;
            border-radius: 3px;
            border: 1px solid #ccc;
        }
        .active-mode-btn {
            border: 2px solid #007bff;
            background-color: #e0f7ff;
        }

        /* Estilos de las Fichas de Control de Pizarra */
        .token-item {
            display: inline-flex;
            align-items: center;
            margin: 5px 10px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 5px;
            cursor: pointer;
            background-color: #fff;
        }
        .token-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
            border: 1px solid #333;
        }
        .token-active {
            border: 2px solid gold;
            box-shadow: 0 0 5px orange;
            background-color: #ffe0b2;
        }

        /* Estilos para la Tabla de Notas del Mapa */
        .map-notes-section {
            border: 1px solid #ccc;
            margin-top: 20px;
            padding: 10px;
            background-color: #fff;
            border-radius: 3px;
        }
        .map-notes-section table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }
        .map-notes-section th, .map-notes-section td {
            border: 1px solid #eee;
            padding: 8px;
            text-align: left;
        }
        .map-notes-section th {
            background-color: #f2f2f2;
        }
        .map-notes-section input[type="text"] {
            width: 95%;
            padding: 3px;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>campo de batalla</h1>

    <h2>Fichas de Aventureros</h2>
    <div class="players-section" id="players-section">
        
        <div class="player-card" data-card-type="player" data-card-id="1">
            <button class="remove-card-btn" onclick="removeCard(this)">✖</button>
            <h3>Jugador 1</h3>
            <label for="nombre1">Nombre:</label>
            <input type="text" id="nombre1" class="card-name" value="Kaelen">
            
            <label for="token_color_1">Color de Ficha:</label>
            <input type="color" id="token_color_1" class="token-color-input" value="#007bff" onchange="updateTokenControls()">
            
            <label for="raza1">Raza/Clase:</label>
            <input type="text" id="raza1" value="Guerrero Elfo">

            <label for="pv1">Puntos de Vida (PV):</label>
            <input type="number" id="pv1" class="pv-input" data-card-name-ref="nombre1" value="15" min="0">

            <label for="ca1">Clase de Armadura (CA):</label>
            <input type="number" id="ca1" value="16" min="10">

            <label for="eq1">Equipo/Arma Principal:</label>
            <input type="text" id="eq1" value="Espada Larga y Escudo">

            <label for="inv1">Inventario/Equipo:</label>
            <textarea id="inv1">Ración de 3 días, 50 pies de cuerda, 10g, Pócima de Curación (2)</textarea>
        </div>

        <div class="player-card" data-card-type="player" data-card-id="2">
            <button class="remove-card-btn" onclick="removeCard(this)">✖</button>
            <h3>Jugador 2</h3>
            <label for="nombre2">Nombre:</label>
            <input type="text" id="nombre2" class="card-name" value="Lyra">
            
            <label for="token_color_2">Color de Ficha:</label>
            <input type="color" id="token_color_2" class="token-color-input" value="#9900cc" onchange="updateTokenControls()">
            
            <label for="raza2">Raza/Clase:</label>
            <input type="text" id="raza2" value="Pícaro Mediano">

            <label for="pv2">Puntos de Vida (PV):</label>
            <input type="number" id="pv2" class="pv-input" data-card-name-ref="nombre2" value="12" min="0">

            <label for="ca2">Clase de Armadura (CA):</label>
            <input type="number" id="ca2" value="14" min="10">

            <label for="eq2">Equipo/Habilidad Clave:</label>
            <input type="text" id="eq2" value="Herramientas de ladrón">

            <label for="inv2">Inventario/Equipo:</label>
            <textarea id="inv2">Dagas (4), Armadura de cuero, Ganzúas de mithril.</textarea>
        </div>

        <div class="player-card" data-card-type="player" data-card-id="3">
            <button class="remove-card-btn" onclick="removeCard(this)">✖</button>
            <h3>Jugador 3</h3>
            <label for="nombre3">Nombre:</label>
            <input type="text" id="nombre3" class="card-name" value="Zydros">
            
            <label for="token_color_3">Color de Ficha:</label>
            <input type="color" id="token_color_3" class="token-color-input" value="#008000" onchange="updateTokenControls()">
            
            <label for="raza3">Raza/Clase:</label>
            <input type="text" id="raza3" value="Mago Humano">

            <label for="pv3">Puntos de Vida (PV):</label>
            <input type="number" id="pv3" class="pv-input" data-card-name-ref="nombre3" value="10" min="0">

            <label for="ca3">Clase de Armadura (CA):</label>
            <input type="number" id="ca3" value="12" min="10">

            <label for="eq3">Equipo/Hechizo Clave:</label>
            <input type="text" id="eq3" value="Misil Mágico">

            <label for="inv3">Inventario/Equipo:</label>
            <textarea id="inv3">Libro de Hechizos, Bastón arcano, 50g, Componentes básicos.</textarea>
        </div>
    </div>
    
    <div class="add-card-btn-container">
        <button class="add-card-btn" onclick="addCard('player')">➕ Agregar Personaje</button>
    </div>

    <hr>
    
    <h2>Fichas de Enemigos y PNJs Clave</h2>

    <div class="enemies-section" id="enemies-section">
        <div class="enemy-card" data-card-type="enemy" data-card-id="1">
            <button class="remove-card-btn" onclick="removeCard(this)">✖</button>
            <h3>Enemigo 1</h3>
            <label for="enemigo_name_1">Nombre:</label>
            <input type="text" id="enemigo_name_1" class="card-name" value="Líder Goblin">
            
            <label for="enemigo_type_1">Tipo/Rol:</label>
            <input type="text" id="enemigo_type_1" value="Bestia / Jefe">

            <label for="enemigo_pv_1">Puntos de Vida (PV):</label>
            <input type="number" id="enemigo_pv_1" class="pv-input" data-card-name-ref="enemigo_name_1" value="15" min="0">

            <label for="enemigo_ca_1">Clase de Armadura (CA):</label>
            <input type="number" id="enemigo_ca_1" value="14" min="10">
        </div>
        
    </div>
    
    <div class="add-card-btn-container">
        <button class="add-card-btn add-enemy-btn" onclick="addCard('enemy')">➕ Agregar Enemigo/PNJ</button>
    </div>

    <hr>
    
    <div class="map-section">
        <h2>Pizarra de Mapas / Lienzo de Combate 🎨</h2>
        <p>Tamaño del mapa: 80x40 casillas (10px/casilla). **Haz clic para colocar/dibujar/borrar.**</p>

        <div class="canvas-controls">
            
            <div>
                <button id="mode-line-btn" onclick="setMode('line', this)" class="active-mode-btn">✏️ Dibujar (Lápiz)</button>
                <button id="mode-token-btn" onclick="setMode('token', this)">🎯 Colocar Ficha</button>
            </div>
            
            <div>
                <label for="drawing-mode">Objeto:</label>
                <select id="drawing-mode" onchange="setMode(this.value, this); updateCanvasCursor(this.value);">
                    <option value="eraser">❌ Borrar Objetos</option>
                    <option value="rock">🪨 Roca/Obstáculo</option>
                    <option value="tree">🌳 Árbol/Cobertura</option>
                    <option value="note">📌 Añadir Nota/Pin</option>
                    <option value="house">🏠 Casa</option>
                    <option value="castle">🏰 Castillo</option>
                </select>
            </div>

            <div id="drawing-controls">
                <label for="brush-color">Color:</label>
                <input type="color" id="brush-color" value="#000000">

                <label for="brush-size">Grosor:</label>
                <input type="number" id="brush-size" value="3" min="1" max="10" style="width: 50px;">
            </div>
            
            <button onclick="clearCanvas()">🗑️ Borrar Todo</button>
        </div>
        
        <div class="canvas-controls" id="token-controls">
            <p>**Tokens de Personajes/Enemigos:** (Haz clic para seleccionar la ficha a colocar)</p>
        </div>

        <canvas id="drawing-canvas" width="800" height="400"></canvas>
    </div>

    <div class="map-notes-section">
        <h2>Notas del Mapa (Pins)</h2>
        <p>Aquí puedes gestionar las descripciones de los pins que has colocado en la pizarra. La primera letra de la descripción se muestra en el mapa.</p>
        <table id="map-notes-table">
            <thead>
                <tr>
                    <th>Pin</th>
                    <th>Coordenadas (Celda)</th>
                    <th>Descripción</th>
                    <th>Acción</th>
                </tr>
            </thead>
            <tbody>
                </tbody>
        </table>
    </div>

    <hr>
    
    <div class="main-sections">
        <div class="journal-section">
            <h2>Diario de la Campaña (Para el DM o el Anotador)</h2>
            <p>Utiliza este espacio para registrar la historia, los PNJs, las pistas y las misiones activas.</p>
            <textarea id="adventure-journal">
-- DÍA 1: La taberna "El Dragón Dormido" --

El grupo de aventureros se reunió en la ciudad de Puerto Bruma. La posadera, Elara, les ha ofrecido una recompensa de 50 monedas de oro si logran recuperar un anillo familiar que fue robado por Goblins del Bosque Susurrante.

PNJs Importantes:
- Elara (Posadera): Preocupada, tiene una cicatriz en la mano.
- Capitán Borin (Guardia): No cree en las historias de Goblins.

Pistas:
- Los Goblins se dirigen hacia el Este, al viejo molino abandonado.

Misión Actual:
- Recuperar el Anillo de la Familia de Elara del molino abandonado.
            </textarea>
        </div>

        <div class="combat-control-section">
            <h2>Control de Combate y Calculadora</h2>
            <p>Gestión rápida de los Puntos de Vida de **cualquier ficha** (Jugador o Enemigo).</p>
            
            <div class="pv-calculator">
                <label for="pv-target">Ficha a modificar:</label>
                <select id="pv-target"></select>

                <label for="pv-amount">Monto:</label>
                <input type="number" id="pv-amount" value="5" min="1" style="width: 50px;">
                
                <button class="damage-btn" onclick="modifyPV(-1)">Recibir Daño (-)</button>
                <button class="heal-btn" onclick="modifyPV(1)">Sanar/Ganar PV (+)</button>
            </div>

            <h2 style="margin-top: 15px;">Notas de Combate Rápido</h2>
            <p>Usa este espacio para anotar la CA de los enemigos genéricos, condiciones, etc.</p>
            <textarea id="combat-notes" min-height="100px;">
CA Enemigo Genérico: 13 (Goblin)
Condiciones: Kaelen: Bendecido (siguiente ataque con ventaja)
            </textarea>
        </div>
    </div>
    
    <div class="dice-roller">
        <h2>Lanzador de Dados</h2>
        <p>¡Lanza el dado para ataques, salvaciones o pruebas de habilidad!</p>
        <button onclick="rollDice(4)">Tirar D4</button>
        <button onclick="rollDice(6)">Tirar D6</button>
        <button onclick="rollDice(8)">Tirar D8</button>
        <button onclick="rollDice(10)">Tirar D10</button>
        <button onclick="rollDice(12)">Tirar D12</button>
        <button onclick="rollDice(20)">Tirar D20 (Prueba/Ataque)</button>
        
        <div class="dice-result" id="result">
            Resultado: -
        </div>
    </div>
    
    <script>
        let playerCount = 3; 
        let enemyCount = 1;
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 400;
        const GRID_SIZE = 10; 

        // --- Variables de la Pizarra ---
        const canvas = document.getElementById('drawing-canvas');
        const ctx = canvas.getContext('2d');
        const drawingModeSelect = document.getElementById('drawing-mode');
        const notesTableBody = document.querySelector('#map-notes-table tbody');
        
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let selectedToken = null; 
        let tokensOnMap = []; 
        let mapObjects = []; 
        let currentMode = 'line'; 

        const TOKEN_RADIUS = 5; 

        // ----------------------------------------------------------------
        // --- Inicialización y Eventos de Setup ---
        // ----------------------------------------------------------------
        
        document.addEventListener('DOMContentLoaded', () => {
            updatePVTargetSelector();
            setupCanvas();
            updateTokenControls(); 
            redrawMap();
            setMode('line', document.getElementById('mode-line-btn'));
        });
        
        function setMode(mode, element) {
            currentMode = mode;
            isDrawing = false;
            selectToken(null); // Deseleccionar token al cambiar de modo
            
            const mainModes = ['line', 'token'];
            
            // Si el modo es un objeto, deseleccionar los botones de modo principales
            if (!mainModes.includes(mode)) {
                document.getElementById('mode-line-btn').classList.remove('active-mode-btn');
                document.getElementById('mode-token-btn').classList.remove('active-mode-btn');
                drawingModeSelect.value = mode;
            } else {
                // Si el modo es lápiz o token, actualizar botones principales
                document.querySelectorAll('.canvas-controls button').forEach(btn => {
                    btn.classList.remove('active-mode-btn');
                });
                if (mode === 'line') {
                    document.getElementById('mode-line-btn').classList.add('active-mode-btn');
                    drawingModeSelect.value = 'eraser'; 
                } else if (mode === 'token') {
                     document.getElementById('mode-token-btn').classList.add('active-mode-btn');
                     drawingModeSelect.value = 'eraser';
                }
            }
            
            updateCanvasCursor(mode);
        }

        // ----------------------------------------------------------------
        // --- Funciones de Pizarra (Canvas) ---
        // ----------------------------------------------------------------
        
        function setupCanvas() {
            // Eventos de Interacción
            canvas.addEventListener('mousedown', startInteraction);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopInteraction);
            canvas.addEventListener('mouseout', stopInteraction);
            canvas.addEventListener('click', handleClick);
            
            document.getElementById('players-section').addEventListener('change', (e) => {
                if (e.target.classList.contains('card-name') || e.target.classList.contains('token-color-input')) {
                    updateTokenControls();
                    redrawMap();
                }
            });
            document.getElementById('enemies-section').addEventListener('change', (e) => {
                if (e.target.classList.contains('card-name')) {
                    updateTokenControls();
                    redrawMap();
                }
            });
            
            // Event listener para actualizar el mapa cuando se edita la descripción de la nota
            notesTableBody.addEventListener('input', (e) => {
                if (e.target.classList.contains('note-text-input')) {
                    const rowIndex = parseInt(e.target.closest('tr').dataset.index);
                    const mapObjectIndex = parseInt(e.target.closest('tr').dataset.mapIndex);
                    
                    if(mapObjects[mapObjectIndex]) {
                         mapObjects[mapObjectIndex].text = e.target.value;
                         redrawMap();
                    }
                }
            });
        }
        
        function updateCanvasCursor(mode) {
            switch (mode) {
                case 'token':
                case 'rock':
                case 'tree':
                case 'note':
                case 'eraser':
                case 'house':
                case 'castle':
                    canvas.style.cursor = 'pointer';
                    break;
                case 'line':
                default:
                    canvas.style.cursor = 'crosshair';
                    break;
            }
        }

        /** Inicia la interacción (dibujo). */
        function startInteraction(e) {
            // Se usa offset en lugar de getMapCoordinates
            const x = e.offsetX;
            const y = e.offsetY;
            
            if (currentMode === 'line') {
                isDrawing = true;
                [lastX, lastY] = [x, y];
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
            }
        }

        /** Realiza el trazo de dibujo. */
        function draw(e) {
            if (!isDrawing) return;

            const x = e.offsetX;
            const y = e.offsetY;

            ctx.lineWidth = parseInt(document.getElementById('brush-size').value);
            ctx.lineCap = 'round';
            ctx.strokeStyle = document.getElementById('brush-color').value;

            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y);
            
            [lastX, lastY] = [x, y];
        }

        /** Detiene la interacción. */
        function stopInteraction() {
            if (isDrawing) {
                isDrawing = false;
                ctx.closePath();
            }
        }
        
        /** Maneja el clic para colocar objetos o tokens. */
        function handleClick(e) {
            if (isDrawing) return; // Ignorar clic si estamos dibujando
            
            const x = e.offsetX;
            const y = e.offsetY;

            // Ajustar a la cuadrícula (centro de la celda de 10x10)
            const gridCellX = Math.floor(x / GRID_SIZE) * GRID_SIZE + (GRID_SIZE / 2);
            const gridCellY = Math.floor(y / GRID_SIZE) * GRID_SIZE + (GRID_SIZE / 2);
            
            const cellLabel = `${Math.floor(gridCellX / GRID_SIZE)}x${Math.floor(gridCellY / GRID_SIZE)}`;

            switch (currentMode) {
                case 'token':
                    if (selectedToken) placeToken(gridCellX, gridCellY);
                    break;
                case 'rock':
                case 'tree':
                case 'house':
                case 'castle':
                    placeObject(gridCellX, gridCellY, currentMode);
                    break;
                case 'note':
                    placeNote(gridCellX, gridCellY, cellLabel);
                    break;
                case 'eraser':
                    eraseObject(gridCellX, gridCellY);
                    break;
            }
        }
        
        // ----------------------------------------------------------------
        // --- Lógica de Dibujo y Objetos Estáticos ---
        // ----------------------------------------------------------------

        function drawGrid() {
            ctx.strokeStyle = '#e0e0e0'; 
            ctx.lineWidth = 1; 
            
            const numCellsX = CANVAS_WIDTH / GRID_SIZE;
            const numCellsY = CANVAS_HEIGHT / GRID_SIZE;
            
            for (let i = 0; i <= numCellsX; i++) {
                const x = i * GRID_SIZE;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, CANVAS_HEIGHT);
                ctx.stroke();
            }

            for (let i = 0; i <= numCellsY; i++) {
                const y = i * GRID_SIZE;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(0 + CANVAS_WIDTH, y);
                ctx.stroke();
            }
        }

        /** Dibuja un objeto estático (Roca, Árbol, Casa, Castillo, Nota) en la posición dada. */
        function drawObject(obj) {
            const size = GRID_SIZE; // 10px
            const halfSize = size / 2;
            const x = obj.x - halfSize; // Esquina superior izquierda de la celda
            const y = obj.y - halfSize;
            
            ctx.lineWidth = 1; 
            
            switch (obj.type) {
                case 'rock':
                    ctx.fillStyle = '#808080';
                    ctx.fillRect(x + 1, y + 1, size - 2, size - 2);
                    ctx.strokeStyle = '#333';
                    ctx.strokeRect(x + 1, y + 1, size - 2, size - 2);
                    break;
                case 'tree':
                    ctx.fillStyle = '#228B22'; // Verde
                    ctx.beginPath();
                    ctx.arc(obj.x, obj.y, halfSize - 1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#006400';
                    ctx.stroke();
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(obj.x - 1, obj.y, 2, halfSize);
                    break;
                case 'house':
                    ctx.fillStyle = '#A0522D';
                    ctx.beginPath();
                    ctx.moveTo(x, y + halfSize);
                    ctx.lineTo(x + halfSize, y);
                    ctx.lineTo(x + size, y + halfSize);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = '#D2B48C';
                    ctx.fillRect(x + 1, y + halfSize, size - 2, halfSize - 1);
                    ctx.strokeRect(x + 1, y + halfSize, size - 2, halfSize - 1);
                    break;
                case 'castle':
                    ctx.fillStyle = '#B0C4DE';
                    ctx.fillRect(x + 1, y + 2, size - 2, size - 3);
                    ctx.strokeStyle = '#708090';
                    ctx.strokeRect(x + 1, y + 2, size - 2, size - 3);
                    const crenelationSize = size / 3;
                    ctx.fillStyle = '#708090'; 
                    ctx.fillRect(x + 1, y + 1, crenelationSize, 2);
                    ctx.fillRect(x + 1 + crenelationSize, y + 3, crenelationSize, 2);
                    ctx.fillRect(x + 1 + 2 * crenelationSize, y + 1, crenelationSize, 2);
                    break;
                case 'note':
                    ctx.fillStyle = '#FFD700'; 
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 2;

                    ctx.beginPath();
                    ctx.moveTo(obj.x, obj.y - halfSize + 1); 
                    ctx.lineTo(obj.x + 3, obj.y - 1);
                    ctx.lineTo(obj.x - 3, obj.y - 1);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(obj.x, obj.y + 1, 3, 0, Math.PI * 2);
                    ctx.fillStyle = '#FFD700';
                    ctx.fill();
                    ctx.stroke();

                    // Mostrar la primera letra de la nota (cambio para texto)
                    if (obj.text && obj.text.trim().length > 0) {
                        ctx.fillStyle = '#333';
                        ctx.font = `bold 5px Arial`; 
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        let initial = obj.text.trim().substring(0, 1).toUpperCase();
                        ctx.fillText(initial, obj.x, obj.y + 1); 
                    }
                    break;
            }
        }
        
        function placeObject(x, y, type) {
            const existingIndex = mapObjects.findIndex(obj => obj.x === x && obj.y === y);

            if (existingIndex !== -1 && mapObjects[existingIndex].type === type) {
                // Borrar el objeto si ya existe en esa posición y es del mismo tipo
                mapObjects.splice(existingIndex, 1);
            } else if (existingIndex !== -1) {
                // Si ya hay un objeto pero es de otro tipo, reemplazarlo
                mapObjects[existingIndex] = { x: x, y: y, type };
            } else {
                // Añadir un nuevo objeto
                mapObjects.push({ x: x, y: y, type });
            }
            
            redrawMap();
            updateMapNotesTable();
        }
        
        function placeNote(x, y, label) {
            const existingIndex = mapObjects.findIndex(obj => obj.x === x && obj.y === y && obj.type === 'note');

            if (existingIndex === -1) {
                mapObjects.push({ 
                    x: x, 
                    y: y, 
                    type: 'note', 
                    text: 'Nueva Nota/Punto de Interés', 
                    label: label
                });
            }
            
            redrawMap();
            updateMapNotesTable();
        }

        function updateMapNotesTable() {
            notesTableBody.innerHTML = '';
            
            const notes = mapObjects.filter(obj => obj.type === 'note');
            
            notes.forEach((note, index) => {
                const row = notesTableBody.insertRow();
                // Encontrar el índice del objeto dentro del array principal mapObjects para referenciarlo en el input listener
                const mapObjectIndex = mapObjects.findIndex(obj => obj === note); 
                
                row.dataset.index = index; 
                row.dataset.mapIndex = mapObjectIndex; // Usar este índice para la edición

                row.insertCell().innerHTML = '📌';
                row.insertCell().textContent = note.label || `${Math.floor(note.x / GRID_SIZE)}x${Math.floor(note.y / GRID_SIZE)}`;
                
                const textCell = row.insertCell();
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'note-text-input';
                input.value = note.text || '';
                input.placeholder = 'Escribe la descripción aquí...';
                textCell.appendChild(input);

                const actionCell = row.insertCell();
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Borrar';
                deleteButton.onclick = () => {
                    // Borrar el objeto usando su índice real en mapObjects
                    mapObjects.splice(mapObjectIndex, 1);
                    redrawMap();
                    updateMapNotesTable();
                };
                actionCell.appendChild(deleteButton);
            });
        }
        
        function eraseObject(x, y) {
            const objectIndex = mapObjects.findIndex(obj => obj.x === x && obj.y === y);
            if (objectIndex !== -1) {
                mapObjects.splice(objectIndex, 1);
                redrawMap();
                updateMapNotesTable();
                return;
            }
            
            const tokenIndex = tokensOnMap.findIndex(token => 
                Math.abs(token.x - x) < GRID_SIZE / 2 && Math.abs(token.y - y) < GRID_SIZE / 2
            );
            
            if (tokenIndex !== -1) {
                tokensOnMap.splice(tokenIndex, 1);
                redrawMap();
            }
        }
        
        function placeToken(x, y) {
            const existingIndex = tokensOnMap.findIndex(token => token.id === selectedToken.id);

            const newTokenData = {
                id: selectedToken.id,
                name: selectedToken.name,
                color: selectedToken.color,
                x: x, 
                y: y
            };

            if (existingIndex !== -1) {
                tokensOnMap[existingIndex] = newTokenData;
            } else {
                tokensOnMap.push(newTokenData);
            }

            selectToken(null);
            redrawMap();
        }

        function drawToken(token) {
            ctx.beginPath();
            ctx.arc(token.x, token.y, TOKEN_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = token.color;
            ctx.fill();
            ctx.lineWidth = 1; 
            ctx.strokeStyle = '#333';
            ctx.stroke();
            
            ctx.fillStyle = (token.color === '#000000' || token.color === '#cc0000' || token.color === '#9900cc' || token.color === '#8b0000') ? '#ffffff' : '#000000';
            ctx.font = `bold 6px Arial`; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            let initial = token.name.substring(0, 1).toUpperCase();
            
            ctx.fillText(initial, token.x, token.y);
        }

        function redrawMap() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); 
            
            drawGrid(); 
            mapObjects.forEach(drawObject); 
            tokensOnMap.forEach(drawToken); 
        }

        function clearCanvas(clearAll = true) {
            if (clearAll) {
                tokensOnMap = [];
                mapObjects = [];
                selectToken(null);
                updateMapNotesTable(); 
            }
            redrawMap(); 
        }
        
        function selectToken(tokenElement) {
            const controls = document.querySelectorAll('.token-item');
            controls.forEach(control => control.classList.remove('token-active'));
            
            if (tokenElement && selectedToken && selectedToken.id === tokenElement.dataset.id) {
                selectedToken = null;
                setMode('line', document.getElementById('mode-line-btn'));
            } else if (tokenElement) {
                tokenElement.classList.add('token-active');
                selectedToken = {
                    id: tokenElement.dataset.id,
                    name: tokenElement.dataset.name,
                    color: tokenElement.dataset.color
                };
                setMode('token', document.getElementById('mode-token-btn'));
            } else {
                selectedToken = null;
            }
            
            isDrawing = false;
        }

        function updateTokenControls() {
            const tokenControlsDiv = document.getElementById('token-controls');
            tokenControlsDiv.innerHTML = '<p>**Tokens de Personajes/Enemigos:** (Haz clic para seleccionar la ficha a colocar)</p>';

            const allCards = document.querySelectorAll('.player-card, .enemy-card');
            
            allCards.forEach(card => {
                const type = card.dataset.cardType;
                const cardId = card.dataset.cardId;

                const pvInput = card.querySelector('.pv-input');
                if (!pvInput) return; 
                const id = pvInput.id; 

                const nameInput = card.querySelector('.card-name');
                const name = nameInput ? nameInput.value : (type === 'player' ? `Jugador ${cardId}` : `Enemigo ${cardId}`);
                
                let color;
                if (type === 'player') {
                    const colorInput = card.querySelector('.token-color-input');
                    color = colorInput ? colorInput.value : '#3498db'; 
                } else {
                    color = '#cc0000'; 
                }

                const existingTokenIndex = tokensOnMap.findIndex(token => token.id === id);
                if(existingTokenIndex !== -1) {
                    tokensOnMap[existingTokenIndex].color = color;
                    tokensOnMap[existingTokenIndex].name = name;
                }

                const control = createTokenControlElement(id, name, color);
                tokenControlsDiv.appendChild(control);
            });
            redrawMap(); 
        }

        function createTokenControlElement(id, name, color) {
            const tokenElement = document.createElement('div');
            tokenElement.className = 'token-item';
            tokenElement.dataset.id = id;
            tokenElement.dataset.name = name;
            tokenElement.dataset.color = color;
            tokenElement.onclick = () => {
                selectToken(tokenElement);
            };

            const colorCircle = document.createElement('span');
            colorCircle.className = 'token-color';
            colorCircle.style.backgroundColor = color;
            
            tokenElement.appendChild(colorCircle);
            tokenElement.appendChild(document.createTextNode(name));

            return tokenElement;
        }

        // ----------------------------------------------------------------
        // --- Funciones de Dados y Fichas (Lógica original) ---
        // ----------------------------------------------------------------

        function rollDice(sides) {
            const result = Math.floor(Math.random() * sides) + 1;
            const resultElement = document.getElementById('result');
            resultElement.innerHTML = `Tirada de D${sides}: **${result}**`;

            if (sides === 20) {
                if (result === 20) {
                    resultElement.innerHTML += " **¡Éxito Crítico!**";
                    resultElement.style.color = '#ff6600'; 
                } else if (result === 1) {
                    resultElement.innerHTML += " **¡Fallo Crítico!**";
                    resultElement.style.color = '#cc0000'; 
                } else {
                    resultElement.style.color = '#008000'; 
                }
            } else {
                resultElement.style.color = '#008000'; 
            }
        }

        function modifyPV(modifier) {
            const targetId = document.getElementById('pv-target').value;
            const amountInput = document.getElementById('pv-amount');
            const amount = parseInt(amountInput.value);
            const targetInput = document.getElementById(targetId);
            
            if (!targetInput || isNaN(amount) || amount <= 0) {
                alert("Por favor, selecciona una ficha y un monto válido.");
                return;
            }

            let currentPV = parseInt(targetInput.value);
            let newPV;
            let logMessage;

            if (modifier > 0) {
                newPV = currentPV + amount;
                logMessage = `+${amount} PV a ${targetInput.dataset.cardName} (PV actual: ${newPV})`;
            } else {
                newPV = currentPV - amount;
                if (newPV < 0) newPV = 0; 
                logMessage = `-${amount} PV de DAÑO a ${targetInput.dataset.cardName} (PV actual: ${newPV})`;
            }

            targetInput.value = newPV;
            targetInput.focus();

            const combatNotes = document.getElementById('combat-notes');
            combatNotes.value += `\n[${new Date().toLocaleTimeString()}] ${logMessage}`;
            combatNotes.scrollTop = combatNotes.scrollHeight;
        }

        function createCardHTML(type, id) {
            const isPlayer = type === 'player';
            const cardClass = isPlayer ? 'player-card' : 'enemy-card';
            const title = isPlayer ? `Jugador ${id}` : `Enemigo ${id}`;
            const nameId = isPlayer ? `nombre${id}` : `enemigo_name_${id}`;
            const pvId = isPlayer ? `pv${id}` : `enemigo_pv_${id}`;
            const caId = isPlayer ? `ca${id}` : `enemigo_ca_${id}`;
            const otherLabel = isPlayer ? 'Raza/Clase:' : 'Tipo/Rol:';
            const otherId = isPlayer ? `raza${id}` : `enemigo_type_${id}`;
            const otherValue = isPlayer ? 'Clase por Defecto' : 'Tipo por Defecto';
            
            const colorField = isPlayer ? 
                `<label for="token_color_${id}">Color de Ficha:</label>
                <input type="color" id="token_color_${id}" class="token-color-input" value="#3498db" onchange="updateTokenControls()">` : '';
                
            const extraField = isPlayer ? 
                `<label for="eq${id}">Equipo/Habilidad Clave:</label><input type="text" id="eq${id}" value="Equipo Básico">
                 <label for="inv${id}">Inventario/Equipo:</label><textarea id="inv${id}">Inventario vacío.</textarea>` : 
                '';

            return `
                <div class="${cardClass}" data-card-type="${type}" data-card-id="${id}">
                    <button class="remove-card-btn" onclick="removeCard(this)">✖</button>
                    <h3>${title}</h3>
                    <label for="${nameId}">Nombre:</label>
                    <input type="text" id="${nameId}" class="card-name" value="${isPlayer ? 'Nuevo Héroe' : 'Nuevo Enemigo'}">
                    
                    ${colorField}
                    
                    <label for="${otherId}">${otherLabel}</label>
                    <input type="text" id="${otherId}" value="${otherValue}">

                    <label for="${pvId}">Puntos de Vida (PV):</label>
                    <input type="number" id="${pvId}" class="pv-input" data-card-name-ref="${nameId}" value="10" min="0">

                    <label for="${caId}">Clase de Armadura (CA):</label>
                    <input type="number" id="${caId}" value="10" min="10">
                    ${extraField}
                </div>
            `;
        }
        
        function addCard(type) {
            let id;
            let section;

            if (type === 'player') {
                playerCount++;
                id = playerCount;
                section = document.getElementById('players-section');
            } else {
                enemyCount++;
                id = enemyCount;
                section = document.getElementById('enemies-section');
            }
            
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = createCardHTML(type, id).trim();
            
            section.appendChild(tempDiv.firstChild);

            updatePVTargetSelector();
            updateTokenControls(); 
        }

        function removeCard(button) {
            if (confirm("¿Estás seguro de que quieres eliminar esta ficha?")) {
                const card = button.closest('.player-card, .enemy-card');
                
                const pvInput = card.querySelector('.pv-input');
                const pvId = pvInput ? pvInput.id : null;
                
                card.remove();

                if (pvId) {
                    tokensOnMap = tokensOnMap.filter(token => token.id !== pvId);
                    redrawMap();
                }

                updatePVTargetSelector();
                updateTokenControls(); 
            }
        }

        function updatePVTargetSelector() {
            const selector = document.getElementById('pv-target');
            selector.innerHTML = ''; 
            
            const pvInputs = document.querySelectorAll('.pv-input');

            pvInputs.forEach(pvInput => {
                const pvId = pvInput.id;
                
                const nameInputId = pvInput.dataset.cardNameRef;
                const nameInput = document.getElementById(nameInputId);
                
                const name = nameInput ? (nameInput.value || `Ficha ID: ${pvId}`) : pvId;

                pvInput.dataset.cardName = name;

                const option = document.createElement('option');
                option.value = pvId;
                option.textContent = name;
                selector.appendChild(option);
            });
            
            if (pvInputs.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = '--- No hay fichas ---';
                selector.appendChild(option);
            }
        }
        
    </script>
</div>

</body>
</html>